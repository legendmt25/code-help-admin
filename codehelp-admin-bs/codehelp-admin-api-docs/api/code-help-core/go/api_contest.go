/*
 * Coding helper spec
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package codehelp_core_api

import (
	"encoding/json"
	"net/http"
	"strings"
	"os"

	"github.com/gorilla/mux"
)

// ContestAPIController binds http requests to an api service and writes the service results to the http response
type ContestAPIController struct {
	service ContestAPIServicer
	errorHandler ErrorHandler
}

// ContestAPIOption for how the controller is set up.
type ContestAPIOption func(*ContestAPIController)

// WithContestAPIErrorHandler inject ErrorHandler into controller
func WithContestAPIErrorHandler(h ErrorHandler) ContestAPIOption {
	return func(c *ContestAPIController) {
		c.errorHandler = h
	}
}

// NewContestAPIController creates a default api controller
func NewContestAPIController(s ContestAPIServicer, opts ...ContestAPIOption) Router {
	controller := &ContestAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the ContestAPIController
func (c *ContestAPIController) Routes() Routes {
	return Routes{
		"CloseContest": Route{
			strings.ToUpper("Get"),
			"/api/contest/{id}/close",
			c.CloseContest,
		},
		"CreateContestEntry": Route{
			strings.ToUpper("Post"),
			"/api/contests",
			c.CreateContestEntry,
		},
		"CreateContestProblemEntry": Route{
			strings.ToUpper("Post"),
			"/api/contests/{id}",
			c.CreateContestProblemEntry,
		},
		"DeleteContestEntry": Route{
			strings.ToUpper("Delete"),
			"/api/contests/{id}",
			c.DeleteContestEntry,
		},
		"DeleteContestProblem": Route{
			strings.ToUpper("Delete"),
			"/api/contest/{contestId}/problems/{problemId}",
			c.DeleteContestProblem,
		},
		"EditContestEntry": Route{
			strings.ToUpper("Put"),
			"/api/contests/{id}",
			c.EditContestEntry,
		},
		"GetContestEntries": Route{
			strings.ToUpper("Get"),
			"/api/contests",
			c.GetContestEntries,
		},
		"GetContestEntry": Route{
			strings.ToUpper("Get"),
			"/api/contests/{id}",
			c.GetContestEntry,
		},
		"GetContestProblem": Route{
			strings.ToUpper("Get"),
			"/api/contest/{contestId}/problems/{problemId}",
			c.GetContestProblem,
		},
		"SetContestProblemScore": Route{
			strings.ToUpper("Post"),
			"/api/contest/{contestId}/problems/{problemId}/set-score",
			c.SetContestProblemScore,
		},
		"StartContest": Route{
			strings.ToUpper("Get"),
			"/api/contest/{id}/start",
			c.StartContest,
		},
	}
}

// CloseContest - 
func (c *ContestAPIController) CloseContest(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.CloseContest(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateContestEntry - 
func (c *ContestAPIController) CreateContestEntry(w http.ResponseWriter, r *http.Request) {
	contestBaseEntryParam := ContestBaseEntry{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&contestBaseEntryParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertContestBaseEntryRequired(contestBaseEntryParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertContestBaseEntryConstraints(contestBaseEntryParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateContestEntry(r.Context(), contestBaseEntryParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateContestProblemEntry - 
func (c *ContestAPIController) CreateContestProblemEntry(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	
	
	titleParam := r.FormValue("title")
	
	
	difficultyParam := r.FormValue("difficulty")
	var starterCodeParam *os.File
	{
		param, err := ReadFormFileToTempFile(r, "starterCode")
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		starterCodeParam = param
	}
	
	
	var runnerCodeParam *os.File
	{
		param, err := ReadFormFileToTempFile(r, "runnerCode")
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		runnerCodeParam = param
	}
	
	
	var testCasesParam []*os.File
	{
		param, err := ReadFormFilesToTempFiles(r, "testCases")
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		testCasesParam = param
	}
	
	
	
	
	categoryParam := r.FormValue("category")
	
	
	markdownParam := r.FormValue("markdown")
	result, err := c.service.CreateContestProblemEntry(r.Context(), idParam, titleParam, difficultyParam, starterCodeParam, runnerCodeParam, testCasesParam, categoryParam, markdownParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteContestEntry - 
func (c *ContestAPIController) DeleteContestEntry(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.DeleteContestEntry(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteContestProblem - 
func (c *ContestAPIController) DeleteContestProblem(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	contestIdParam, err := parseNumericParameter[int32](
		params["contestId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	problemIdParam, err := parseNumericParameter[int32](
		params["problemId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.DeleteContestProblem(r.Context(), contestIdParam, problemIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// EditContestEntry - 
func (c *ContestAPIController) EditContestEntry(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	contestBaseEntryParam := ContestBaseEntry{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&contestBaseEntryParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertContestBaseEntryRequired(contestBaseEntryParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertContestBaseEntryConstraints(contestBaseEntryParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.EditContestEntry(r.Context(), idParam, contestBaseEntryParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetContestEntries - 
func (c *ContestAPIController) GetContestEntries(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.GetContestEntries(r.Context())
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetContestEntry - 
func (c *ContestAPIController) GetContestEntry(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.GetContestEntry(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetContestProblem - 
func (c *ContestAPIController) GetContestProblem(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	contestIdParam, err := parseNumericParameter[int32](
		params["contestId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	problemIdParam, err := parseNumericParameter[int32](
		params["problemId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.GetContestProblem(r.Context(), contestIdParam, problemIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// SetContestProblemScore - 
func (c *ContestAPIController) SetContestProblemScore(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	contestIdParam, err := parseNumericParameter[int32](
		params["contestId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	problemIdParam, err := parseNumericParameter[int32](
		params["problemId"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	setContestProblemScoreRequestParam := SetContestProblemScoreRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&setContestProblemScoreRequestParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertSetContestProblemScoreRequestRequired(setContestProblemScoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertSetContestProblemScoreRequestConstraints(setContestProblemScoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.SetContestProblemScore(r.Context(), contestIdParam, problemIdParam, setContestProblemScoreRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// StartContest - 
func (c *ContestAPIController) StartContest(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam, err := parseNumericParameter[int32](
		params["id"],
		WithRequire[int32](parseInt32),
	)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	result, err := c.service.StartContest(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
